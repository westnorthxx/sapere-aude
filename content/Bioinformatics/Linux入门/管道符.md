管道符与[[重定向]]存在一定共性，都是讲输出结果的方向进行操作

### 背景
如果**想查看 `tree` 输出结果的头几行，可以有如下操作**
```bash
tree ~/ > tree.txt
head tree.txt
```
显然，操作中的 `tree.txt` 有些多余，于是便可使用管道符 `|`
```bash
tree ~/ | head
```
也就是说，`|` 将 `tree` 命令与 `head` 命令相连，让**前者**的输出数据*直接流入* **后者** ，作为输入数据
> [!tips]
> 这相当于将输出结果*重定向* 至下一个命令

### 用于加深理解的例子
先创建一个示例文件
```bash
zhoux@westnorth:~$ echo -e 1\\n2\\n3\\n4\\n5 > alpha.txt
zhoux@westnorth:~$ cat alpha.txt
1
2
3
4
5
```
那么我们如何提取第 3、4 行呢？在仅使用 `head` 和 `tail` 时可以这样做
```bash
head -4 alpha.txt | tail -2 > ~/beta.txt
cat ~/beta.txt
#先读取前4行，再读取前4行的后两行，最后将结果重定向至beta.txt查看
#很好玩吧
```
先读取前 4 行，再读取前 4 行的后两行，最后将结果重定向至 beta. txt 查看

### 特点 1：管道符只传递标准输出
管道符内流动的只能是**标准输出**，(在[[重定向#输出内容的选择]]中提及)，不能直接连接**不接受标准输出的命令**

例子如下
```bash
zhoux@westnorth:~$ ls ./linux_copy/ | rm
rm: missing operand
Try 'rm --help' for more information.
```
可见，`rm` 无法读取 `ls` 的输出
> [!warning]
> 使用 `xargs rm` 可以让 `rm` 读取 `ls` 的结果，然而，`ls` 只会依次输出**文件名**，如果不在当前目录下，`rm` 仍然无法根据只根据文件名进行删除，而必须要使用**完整的相对/绝对路径**，见[[相对路径与绝对路径#注意点]]

